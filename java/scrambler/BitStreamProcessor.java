import java.io.*;import java.io.IOException;import java.util.ArrayList;import java.math.BigInteger;/*** BitStreamProcessor is an input-output tool for handling bit operations* from streams that are byte-oriented. The input stream bytes are passed* through a 32-bit shift register, where they can be pattern-matched,* retrieved, and/or converted back into bytes and written out on the output* stream.* <p>* Revision history:* 11/23/01 - v0.1 released* 12/4/01 - updated skipBits() to handle eof; fixed bug in setDiscardBits()** @author Multimedia Engineering Team - v0.1, v0.2** @version 0.2*/public class BitStreamProcessor{    /**    * Byte-stream representation of bit stream to process    */    private InputStream in;    /**    * Byte-stream representation of post-process input bit stream    */    private OutputStream out;    /**    * The shiftRegister is the physical implementation of three logical    * registers concatonated together. It is 64 bits wide, but only the    * least-significant 48 bits are used. This structure allows the bits of    * the three logical registers to be shifted into each other as bits move    * through each stage of processing.    * <p>    * The three registers are defined as follows (bits labeled    * from least-significant bit of shiftReg):    * <p>    * ON_DECK [bits 1-8]: holds one incoming byte from input stream at a time.    * <br>    * CURRENT [bits 9-40]: bits are shifted into current from ON_DECK.    * Represents "current" 32 bits being examined within bit stream. All    * references to "current" or "next" bits are from the perspective of this    * register's most-significant bit.    * <br>    * DISCARD [bits 41-48]: bits shifted out of CURRENT have been processed.    * DISCARD is a staging area for building up a byte of shifted bits for    * output on output stream.    */    private long shiftReg;    /**    * Counts DOWN bits that have been shifted into the DISCARD register.    * DISCARD holds only 8-bits, so when this count reaches 0, DISCARD should    * be written out as a byte to the output stream.    */    private int discardShiftCount;    /**    * Counts DOWN how many bits have been shifted out of the ON_DECK register.    * ON_DECK holds only 8-bits, so when this count reaches 0, the next byte    * from the input stream should be written into ON_DECK.    */    private int onDeckShiftCount;    /**    * Counts DOWN how many times the current register has been shifted. This is    * important after individual bits have been shifted and we need to re-synch    * with bitstream's byte-alignment.    */    private int currentShiftCount;    /**    * Has the end of the input stream been reached?    */    private boolean eof = false;    // Shift register constants:    /**    * Bitmask for isolating DISCARD logical register bits from physical shift    * register.    */    private static final long DISCARD_BITMASK = 0xff0000000000L;    /**    * Bitmask for isolating CURRENT logical register bits from physical shift    * register.    */    private static final long CURRENT_BITMASK = 0xffffffff00L;    /**    * Bitmask for isolating ON_DECK logical register bits from physical shift    * register.    */    private static final long ON_DECK_BITMASK = 0xffL;    /**    * 1 BYTE = 8 bits...included for clarity of code    */    private static final int ONE_BYTE = 8;    /**    * 1 bit constant...included for clarity of code    */    private static final int ONE_BIT = 1;    /**    * A WORD is the width of the CURRENT register (32-bits)    */    private static final int ONE_WORD = 32;    /**    * Creates a new BitStreamProcessor.    *    * @param inStream   input bytestream representing bitstram to be processed.    * @param outStream output bytestream to represent processed bitstream.    */    public BitStreamProcessor(InputStream inStream, OutputStream outStream)            throws IOException    {        in = inStream;        out = outStream;        shiftReg = 0;        // populate the shiftReg:        for (int i = 0; i < 5; ++i)        {            shiftReg <<= ONE_BYTE;            readInOnDeck();        }        // initialize shift register counts:        discardShiftCount = 8;        onDeckShiftCount = 8;        currentShiftCount = 8;    }    /**    * "Skipped bits" are bits in the stream we are not interested in. Passes    * bits through to output stream without modification.    *    * @param skipCount  number of bits to skip    */    public void skipBits(int skip)    {        //////////////////////////////////////////////////////////////////////        // TO DO: the current method of shifting one-bit at a time might        // be more expensive than shifting 1 bit until DISCARD reg. is full,        // then shifting in bytes, then shifting bits again for any remainder.        // If the typical program skips few bits at a time on average, the        // current method is probably best. If we frequently skip large numbers        // of bits at a time (hundreds?), however, byte-shifting might be        // worthwhile.        //        //////////////////////////////////////////////////////////////////////        for (int i = 0; i < skip && !eof(); ++i)        {            shiftReg <<= ONE_BIT;               // shift left            if (--currentShiftCount == 0)        // check counters                currentShiftCount = 8;            if (--onDeckShiftCount == 0)                readInOnDeck();            if (--discardShiftCount == 0)                writeOutDiscard();        }		if (eof())		{			for (int i = 0; i < ONE_WORD; ++i)			{				shiftReg <<= ONE_BIT;				if (--discardShiftCount == 0)					writeOutDiscard();			}			if (discardShiftCount != 8)	// if there are any bits left in Discard				writeOutDiscard();		}        //////////////////////////////////////////////////////////////////		// NOTE: The preceeding if statement means that if we are searching		// for a pattern in the last n < 32 bits, (of length < 32) it can		// never be "skipped to". Once we reach eof, all 32 remaining bits		// are written out regardless of their content.		//		// Bug? Maybe not.		//        //////////////////////////////////////////////////////////////////    }    /**    * Retrieves, rather than discarding, the next n < 33 bits.    *    * @param numBits   number of bits to get; MUST be 32 or LESS!    * @return   bits retrieved from current position to getCount or end of    * file    */    public long getBits(int numBits)    {        long fetched = 0;        if (numBits <= ONE_WORD)        {            fetched = (getCurrentBits() >>> (ONE_WORD - numBits));            int preserveDiscard = getDiscardBits();            for (int i = 0; i < numBits; ++i)            {                shiftReg <<= 1;                if (--currentShiftCount == 0)        // check counters                    currentShiftCount = 8;                if (--onDeckShiftCount == 0)                    readInOnDeck();            }            shiftReg &= 0xffffffffffL;              // clear out bits left of                                                    // CURRENT reg.            setDiscardBits(preserveDiscard);        // restore DISCARD reg.        }        return fetched;    }    /**    * Reports whether end of input stream has been reached.    *    * @return   true if input stream is spent    */    public boolean eof()    {        return eof;    }    /**    * Reads next n < 33 bits from the CURRENT register MSB-LSB. Does    * not modify the register.    *    * @param numBits    number of bits to read    * @return           the interpreted value of the read bits    */    public long readBits(int numBits)    {        long value = 0;        if (numBits > 0 && numBits <= ONE_WORD)        {            value = ((shiftReg & CURRENT_BITMASK) >>> (40 - numBits));        }        return value;    }    /**    * Checks if the bits in the CURRENT register match a given pattern.    *    * @param pattern    a bit pattern to check for    * @param nBits      number of bits in pattern (1-32); matching is done    * left-to-right (MSB to LSB) in the 32-bit CURRENT register    * @return   true if pattern matches first nBits bits of the CURRENT    * register (MSB-LSB)    */    public boolean currentBitsMatch(int pattern, int nBits)    {        // true if a valid number of bits are requested to check (1-32)        return nBits > 0 && nBits <= ONE_WORD && readBits(nBits) == pattern;    }    /**    * Skips bits until the next occurance of pattern, or end of file reached.    *    * @param pattern    pattern to match    * @param numBits    number of bits in pattern (1-32)    */    public void skipToNext(int pattern, int numBits)    {        if (numBits > 0 && numBits <= ONE_WORD)	// ignore illegal pattern lengths            while (!eof() && !currentBitsMatch(pattern, numBits))            	skipBits(1);    }    /**    * Byte-aligns the CURRENT register to the next byte-division relative to    * the start of the bit stream. Skips 1 to 7 bits to align with next byte.    */    public void byteAlign()    {            shiftReg <<= currentShiftCount;            currentShiftCount = 8;    }    /**    * Writes a bit directly into DISCARD register.    *    * @param one    true for a 1 (set) bit, false for 0    */    public void writeBit(boolean one)    {		int disc = getDiscardBits();		disc <<= 1;		if (one)			disc |= 1;		setDiscardBits(disc);		if (--discardShiftCount == 0)			writeOutDiscard();	}    /**    * Writes the bits that have been shifted out of CURRENT register to the    * output stream. This must be done once per 8 shifts to maintain a correct    * output stream (no lost bits). If there are less than 8 bits in the    * DISCARD register, they are left aligned (with MSB) to maintain correct    * output stream.    */    private void writeOutDiscard()    {        try        {            //////////////////////////////////////////////////////////////            // in case the DISCARD register isn't full yet, the bits            // should be left-shifted so the zero padding will be on            // the LSB of the output bitstream. This should only happen            // if the bit stream does not end exactly at a byte-aligned bit            //            // Can this ever happen in a valid MPEG-1 stream?            //            //////////////////////////////////////////////////////////////            out.write(getDiscardBits() << discardShiftCount);        }        catch (IOException e) {e.printStackTrace(); System.exit(0);}        clearDiscard();        discardShiftCount = 8;      // reset the countdown    }    /**    * Reads in the next byte from input stream to the ON_DECK register. Must    * be done once per 8 shifts to avoid (potentially) incorrect bits being    * shifted into CURRENT register.    */    private void readInOnDeck()    {        int nextBits = -1;        try        {            nextBits = in.read();        }        catch (IOException e) {e.printStackTrace(); System.exit(0);}        if (nextBits == -1)            eof = true;        else            setOnDeckBits(nextBits);        onDeckShiftCount = 8;       // reset the countdown    }    /**    * Sets the bits of the CURRENT register.    *    * @param bits   32-bits to write into CURRENT register    */    private void setCurrentBits(long bits)    {        clearCurrent();        shiftReg |= (bits << ONE_BYTE);    }    /**    * Sets the bits of the DISCARD register.    *    * @param bits   8-bits to write into DISCARD register    */    private void setDiscardBits(int bits)    {        clearDiscard();        shiftReg |= ((long) bits << (5 * ONE_BYTE));    }    /**    * Sets the bits of the ON_DECK register.    *    * @param nextByte   next 8-bits waiting to be shifted into CURRENT register    */    private void setOnDeckBits(int nextByte)    {        clearOnDeck();        shiftReg |= nextByte;    }    /**    * Gets contents of DISCARD register.    *    * @return   bits from DISCARD register    */    private int getDiscardBits()    {        return (int) ((shiftReg & DISCARD_BITMASK) >>> 40);    }    /**    * Gets contents of CURRENT register.    *    * @return   bits from CURRENT register    */    private long getCurrentBits()    {        return ((shiftReg & CURRENT_BITMASK) >>> ONE_BYTE);    }    /**    * Gets contents of ON_DECK register.    *    * @return   bits from ON_DECK register    */    private int getOnDeckBits()    {        return (int) (shiftReg & ON_DECK_BITMASK);    }    /**    * Clears bits of the DISCARD register.    */    private void clearDiscard()    {        shiftReg &= ~DISCARD_BITMASK;    }    /**    * Clears the bits of the ON_DECK register.    */    private void clearOnDeck()    {        shiftReg &= ~ON_DECK_BITMASK;    }    /**    * Clears the bits of the CURRENT register.    */    private void clearCurrent()    {        shiftReg &= ~CURRENT_BITMASK;    }}