/***	This is the driver of the application that will scramble or*	descramble mpeg frames according to the given switch.**/import java.io.*;import java.util.*;import java.math.*;public class Scrambler{    private static final int SEQ_START_CODE = 0x000001b3;    private static final int PIC_START_CODE = 0x00000100;    private static final int SLICE_MIN_START_CODE = 0x00000101;    private static final int SLICE_MAX_START_CODE = 0x000001af;	private static BitStreamProcessor myStream;	private static ArrayList slices;    private static ArrayList macroblocks;	private static boolean scrambleMode = true;	private static long myKey = 0;	private static Codec myCodec;    public static void main(String[] args) 	{		myStream = initializeStream(args);		myStream.skipToNext(0x1, 24);        checkValidStreamStart();        printStats();		int iPicCount = 0;        while (!myStream.eof())        {			slices = new ArrayList();            macroblocks = new ArrayList();            skipToNextIPicture();            if (!myStream.eof())            {				++iPicCount;				if ((iPicCount % 10) == 0)					System.out.println("Processing I-Frame " + iPicCount);				skipToNextSliceStart();            	if (!myStream.eof())            	{					processSlices();            		scrambleMacroblocks();					writePicture();				}			}	 	}	 	myStream.skipBits(0);	// to flush any bits left in the register	}///////////////////////////////////////////////////////////////////////////////////	private static void processSlices()	{		// while there's more slices		while(myStream.readBits(32) >= SLICE_MIN_START_CODE &&			  myStream.readBits(32) <= SLICE_MAX_START_CODE)        {			Slice s = getSliceHeader();            do			{				macroblocks.add(getMacroblock());			    ++s.mbCount;			}			while (!myStream.currentBitsMatch(0x0, 23));			// need to skip any padding to next start code here			while (!myStream.currentBitsMatch(0x1, 24))				myStream.getBits(1);			slices.add(s);        } 	} ///////////////////////////////////////////////////////////////////////////////////    private static Macroblock getMacroblock()    {		Macroblock m = new Macroblock();        int[] values = null;        while (myStream.currentBitsMatch(0xf, 11))		// skip macroblock escape        {            m.shiftInBits(myStream.getBits(11), 11);        }        while (myStream.currentBitsMatch(0x8, 11))		// macro block skipping        {		    m.shiftInBits(myStream.getBits(11), 11);        }        Huffmann.decode(11, Huffmann.macro_block_inc, myStream, m);        if (!myStream.currentBitsMatch(0x1, 1))        {			m.shiftInBits(myStream.getBits(6), 6);        }        m.shiftInBits(myStream.getBits(1), 1);        for (int i = 0; i < 6; ++i)        {            if (i < 4) // luminance block            	values = Huffmann.decode(7, Huffmann.dct_size_luminance, myStream, m);            else 	   // chromiance block            	values = Huffmann.decode(8, Huffmann.dct_size_crominance, myStream, m);            int size = values[2];            if (size != 0)			{				m.shiftInBits(myStream.getBits(size), size);		    }            int pValues = Huffmann.decodeCoeff(myStream, m);     		int level, idx_run;   			while ((idx_run = (pValues & 0xff)) != Huffmann.EOB)   			{				if (idx_run == Huffmann.DCT_ESCAPE)				{					idx_run = (int) myStream.getBits(6);					m.shiftInBits(idx_run, 6);					level = (int) myStream.getBits(8);					m.shiftInBits(level, 8);					if ((level & 0x7f) == 0)					{						m.shiftInBits(myStream.getBits(8), 8);					}				}				else				{					m.shiftInBits(myStream.getBits(1), 1);            	}				pValues = Huffmann.decodeCoeff(myStream, m);			}        }        return m; 	} ///////////////////////////////////////////////////////////////////////////////////    private static void skipToNextIPicture()    {		boolean iType = false;        while (!iType && !myStream.eof())        {            myStream.skipToNext(PIC_START_CODE, 32);            if (!myStream.eof())            {				myStream.skipBits(42);            	if (myStream.currentBitsMatch(0x1, 3))    // if picture is an 'I'            	    iType = true;			}        }     } ///////////////////////////////////////////////////////////////////////////////////    private static Slice getSliceHeader()    {	    Slice s = new Slice();        s.shiftInBits(myStream.getBits(32), 32);    // skip start code		s.shiftInBits(myStream.getBits(5), 5);		// skip quant_scale        while (myStream.currentBitsMatch(0x1, 1))        	s.shiftInBits(myStream.getBits(9), 9);        s.shiftInBits(myStream.getBits(1), 1);        return s;    } ///////////////////////////////////////////////////////////////////////////////////    private static void skipToNextSliceStart()    {		long nextBits = myStream.readBits(32);        while (nextBits < SLICE_MIN_START_CODE || nextBits > SLICE_MAX_START_CODE)        {            myStream.skipToNext(0x1, 24);            nextBits = myStream.readBits(32);        }    } ///////////////////////////////////////////////////////////////////////////////////    private static void checkValidStreamStart()    {        if (!myStream.currentBitsMatch(SEQ_START_CODE, 32))        {             System.out.println("This file does not begin with a Sequence " +                               "Start Code. Is this a single-layer (video " +                               "only) MPEG-1 file?" +                               "\n\nGoodbye!\n");             System.exit(0);        }    } ///////////////////////////////////////////////////////////////////////////////////	private static void printStats()	{		myStream.skipBits(32);		int width = (int) myStream.readBits(12);		myStream.skipBits(12);		int height = (int) myStream.readBits(12);		int mbCount = ((width + 15) / 16) * ((height + 15) / 16);		System.out.println("--------------------------------------------------");		System.out.println("Width: " + width + "\nHeight: " + height);        System.out.println("Macroblock count per Picture: " + mbCount);		System.out.println("--------------------------------------------------");		myCodec = new Codec(myKey, mbCount);	} ///////////////////////////////////////////////////////////////////////////////////	private static BitStreamProcessor initializeStream(String[] args)	{		BitStreamProcessor myStream = null;		if (args.length > 3)		{			String mode = args[0];			String inFile = args[1];			String outFile = args[2];			String key = args[3];			scrambleMode = (!mode.toLowerCase().endsWith("d"));			myKey = Long.parseLong(key);			try			{			    FileInputStream in = new FileInputStream(inFile);			    FileOutputStream out = new FileOutputStream(outFile);			    myStream = new BitStreamProcessor(in, out);			}        	catch (Exception e) {e.printStackTrace(); System.exit(0);}		}		else		{			System.out.println("\nUsage: java Scramble -[s|d] [input.mpg] " +							   "[output.mpg] [key]\n");			System.out.println("      -[s|d] : Scramble or Descramble mode");			System.out.println(" [input.mpg] : Input MPEG-1 video layer (only) file");			System.out.println("[output.mpg] : File to output processed MPEG to");			System.out.println("       [key] : 16-digit key (credit card)\n");			System.exit(0);		}   			return myStream;   	} ///////////////////////////////////////////////////////////////////////////////////    private static void scrambleMacroblocks()	{		Macroblock[] sorted = new Macroblock[macroblocks.size()];		if (myKey != 0)		{			for (int i = 0, ix = 0; i < sorted.length; ++i)			{				if (scrambleMode)					ix = myCodec.encode(i);				else					ix = myCodec.decode(i);				sorted[i] = (Macroblock) macroblocks.get(ix);			}		}		else		{			for (int i = 0, ix = 0; i < sorted.length; ++i)			{				if ((i % 2) == 0)	// if i is even				{					if (i != sorted.length)						ix = i + 1;					else						ix = i;				}				else				// if i is odd					ix = i - 1;				sorted[ix] = (Macroblock) macroblocks.get(i);			}		}		for (int i = 0; i < sorted.length; ++i)			macroblocks.set(i, sorted[i]);	} ///////////////////////////////////////////////////////////////////////////////////	private static void writePicture()	{		int bitCount;		int mbIndex = 0;		// for each slice...		for (int sliceNum = 0; sliceNum < slices.size(); ++sliceNum)		{			bitCount = 0;			Slice s = (Slice) slices.get(sliceNum);			// write out the slice header...			for (int sliceBit = 0; sliceBit < s.size(); ++sliceBit)			{				myStream.writeBit(((Boolean) s.get(sliceBit)).booleanValue());				++bitCount;			}			// for each macroblock belonging to this slice...			for (int macCount = 0; macCount < s.mbCount; ++macCount)			{				Macroblock m = (Macroblock) macroblocks.get(mbIndex);				++mbIndex;				// write out the macroblock...				for (int macBit = 0; macBit < m.size(); ++macBit)				{					myStream.writeBit(((Boolean) m.get(macBit)).booleanValue());					++bitCount;				}			}			// zero-padding to maintain byte-alignment of start codes in stream			for (int i = 0; i < (8 - (bitCount % 8)); ++i)				myStream.writeBit(false);		}	}}